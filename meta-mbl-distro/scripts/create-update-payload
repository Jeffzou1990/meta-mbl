#!/usr/bin/env python3
# Copyright (c) 2019 Arm Limited and Contributors. All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause


"""
This script will create an update payload tar archive.

To use the script you can either pass in a space separated list of file names
or a list of bootloader component numbers. Bootloader component numbers
reference a particular bootloader component to update: passing 1 will select
bootloader component 1, etc.

We collect the files/directories which need to be included in the payload,
compress the files/directories with gz and pack them into an uncompressed
tar archive.

The script assumes the files you want to archive are in DEPLOY_DIR_IMAGE in
your MBL workspace.

The script supports multi-component or single component payloads.

Example invocation:

create-update-payload --bootloader-components 1 2 -o tmp/payload.tar

This will create the update payload containing bootloader component 1 and
bootloader component 2 and output the archive to tmp/payload.tar.

The script looks for the files in DEPLOY_DIR_IMAGE, you need to have an MBL
workspace set up and you must have sourced setup-environment.

We have to set the import path relative to this script so python can import the
bitbake and oe libs, the script cannot be moved from the
meta-mbl-distro/scripts folder, as the import paths are relative to the
location of this file.

The script must be executed from TOPDIR, which is the build directory created
when you source setup-environment, or bitbake can't resolve the paths it needs.

TOPDIR is ./mbl-manifest/build-mbl-development or
./mbl-manifest/build-mbl-production in the MBL workspace.
"""

import gzip
import pathlib
import re
import shutil
import sys
import tarfile
import tempfile
import zipfile

# Set the PYTHONPATH so we can import openembedded scripts/lib modules.
oe_scripts_path = (
    pathlib.Path(__file__).resolve().parent.parent.parent.parent
    / "openembedded-core"
    / "scripts"
)

lib_path = oe_scripts_path / "lib"
sys.path.insert(0, str(lib_path))

import scriptpath
import scriptutils

# This is needed so we can import bitbake modules.
bitbakepath = scriptpath.add_bitbake_lib_path()

import bb.tinfoil
import argparse_oe

import pdb
MBL_BOOT_ID = "MBL_BOOT"


def parse_args():
    """Parse the command line arguments."""
    parser = argparse_oe.ArgumentParser(description=__doc__)
    parser.add_argument(
        "-b",
        "--bootloader-components",
        nargs="+",
        help="Space separated list of bootloader component numbers. e.g 1 would"
        " correspond to bootloader component 1.",
    )
    parser.add_argument(
        "-f",
        "--kernel",
        help=(
            "Prepare a payload containing the kernel image."
        ),
        action="store_true",
    )
    parser.add_argument(
        "-o",
        "--tar-output-path",
        type=lambda x: pathlib.Path(x).absolute(),
        default="payload.tar",
        help="Output path for tar archive containing the update payload.",
    )

    args = parser.parse_args()
    if (
        args.bootloader_components is None
        and not args.kernel
    ):
        parser.error("No input arguments given.")

    return args


def get_bitbake_conf_var(var_name, tinfoil):
    val = tinfoil.config_data.getVar(var_name)
    if val is None:
        return val
    return val.strip()


def img_boot_files_val_to_map_val(img_bf_val, image_deploy_dir):
    """
    Convert a value from the IMAGE_BOOT_FILES var to a list of paths.

    The values in the IMAGE_BOOT_FILES var can be a string filename,
    a filename with an 'output name' separated by a semi-colon, or a directory
    with a glob expression. This function will convert these strings to lists
    of Path objects according to the following rules:

    * dir with glob, e.g mbl-bootfiles/*: list of Path objects, each
    representing a file in the directory.

    * filename: a list of Path objects with one element.

    * filename with output name, e.g uImage;kernel: A tuple where
    tuple element 0 is the original file name as a Path and tuple element 1 is
    the output file name as a Path.

    :param img_bf_val str: the IMAGE_BOOT_FILES value.
    :param deploy_dir_img Path: Path to the image deploy dir.
    """
    installed_name_delim = ";"
    if img_bf_val.endswith(r"/*"):
        return list(
            pathlib.Path(image_deploy_dir).glob(img_bf_val)
        )
    elif installed_name_delim in img_bf_val:
        orig_name, installed_name = img_bf_val.split(installed_name_delim)
        return [
            (
                pathlib.Path(image_deploy_dir, orig_name),
                pathlib.Path(installed_name),
            )
        ]
    elif img_bf_val:
        return [pathlib.Path(image_deploy_dir, img_bf_val)]


def match_filenames_to(bootloader_components, deploy_dir, tinfoil=None):
    """
    Look up the bitbake variables corresponding to the bootloader components.

    Parse the bitbake config data using the tinfoil API and match the
    MBL_WKS_BOOTLOADER variable to a bootloader component.

    Return a dict with the variable name as the key and the file name as the
    value.

    :param bootloader_components list: List of bootloader components e.g [1, 2]
    :param tinfoil Tinfoil: bitbake tinfoil object.
    """
    output_map = {}
    for conf_var in tinfoil.config_data:
        match = re.match(r"MBL_WKS_BOOTLOADER_?([A-Z0-9])_FILENAME", conf_var)
        if match and match.group(1).lower() in bootloader_components:
            output_map[conf_var.split("_FILENAME")[0]] = [
                pathlib.Path(
                    deploy_dir,
                    get_bitbake_conf_var(conf_var, tinfoil),
                )
            ]

    return output_map


def match_files_for_boot_part(deploy_dir, tinfoil=None):
    """
    Match all files for the BOOT partition (or BLFS).

    Looks up the value of the IMAGE_BOOT_FILES bb variable.
    Returns a dict with MBL_BOOT as the key and a list of paths as the value.

    :param tinfoil Tinfoil: BitBake tinfoil object.
    """
    image_boot_files = get_bitbake_conf_var(
        "IMAGE_BOOT_FILES", tinfoil
    )
    output_map = {}
    output_map[MBL_BOOT_ID] = list()

    for elem in image_boot_files.split():
        output_map[MBL_BOOT_ID] += img_boot_files_val_to_map_val(
            elem, deploy_dir
        )

    return output_map


def copy_files_to_subdir(paths, dst_dir):
    for path in paths:
        if isinstance(path, tuple):
            src_path = path[0]
            dst_name = path[1].name
        else:
            src_path = path
            dst_name = path.name
        # copy2 preserves file metadata and follows symlinks
        shutil.copy2(str(src_path), str(dst_dir / dst_name))


def copy_single_file_modifying_name(path, new_name, dst_dir):
    if isinstance(path, list) and len(path) > 1 or not isinstance(path, list):
        raise ValueError("Expects a list with a single element.")

    for file_path in path:
        shutil.copy2(str(file_path), str(dst_dir / new_name))


def copy_to_staging_dir(filename_var_map, staging_dir, tinfoil=None):
    """
    Copy files to a staging dir and prepend the file name with the bb varname.

    :param filename_var_map dict: Mapping of bitbake variable names to files.
    :param staging dir Path: path to the dir where the files will be copied to.
    """
    for var, paths in filename_var_map.items():
        if var == MBL_BOOT_ID:
            dst_dir = staging_dir / var
            dst_dir.mkdir(exist_ok=True)
            copy_files_to_subdir(paths, dst_dir)
        else:
            dst_dir = staging_dir
            copy_single_file_modifying_name(paths, var, dst_dir)


def create_tar_archive(tar_archive_name, dir_path, fname_var_map):
    """
    Create a tar archive.

    The tar archive is uncompressed but the files within it are compressed
    using gz.

    :param tar_archive_name str: Path to the tar archive.
    :param dir_path Path: Path to the directory of the files to archive.
    :param fname_var_map dict: Mapping of bitbake variable names to files.
    """
    files_for_tar = []
    for fname in dir_path.iterdir():
        for var in fname_var_map:
            if fname.is_dir():
                gzip_fname = "{}.tar.gz".format(fname.name)
            elif fname.name == var:
                gzip_fname = "{}.tar.gz".format(var)
                break

        gzip_path = dir_path / gzip_fname
        files_for_tar.append(gzip_path)

        with tarfile.open(str(gzip_path), mode="w:gz") as tar_file:
            tar_file.add(str(fname), arcname=gzip_path.name)

    with tarfile.open(tar_archive_name, mode="w") as tar:
        for arc_path in files_for_tar:
            tar.add(str(arc_path), arcname=arc_path.name)


def _bootloader_one_with_kernel(bootloader_components, tinfoil):
    return (
        get_bitbake_conf_var("MBL_WKS_BOOTLOADER1_SKIP", tinfoil) == "1"
        and "1" in bootloader_components
    )


def _kernel_with_bootloader_one(bootloader_components, tinfoil):
    return get_bitbake_conf_var("MBL_WKS_BOOTLOADER1_SKIP", tinfoil) == "1"


def get_payload_files_data(args, tinfoil):
    deploy_dir_img = pathlib.Path(
        get_bitbake_conf_var("DEPLOY_DIR_IMAGE", tinfoil)
    )
    if deploy_dir_img is None:
        raise EnvironmentError(
            "DEPLOY_DIR_IMAGE was not found. "
            "You must be in a valid bitbake environment and you must "
            "have built an MBL image first so DEPLOY_DIR_IMAGE exists."
        )

    fname_var_map = {}
    if args.bootloader_components:
        if _bootloader_one_with_kernel(args.bootloader_components, tinfoil):
            bb.warn(
                "On this target the bootloader 1 component and kernel must "
                "be updated together. Adding kernel to payload..."
            )
            fname_var_map.update(
                match_files_for_boot_part(deploy_dir_img, tinfoil=tinfoil)
            )
            args.bootloader_components.remove("1")

        fname_var_map.update(
            match_filenames_to(
                args.bootloader_components, deploy_dir_img, tinfoil=tinfoil
            )
        )

    if args.kernel:
        if _kernel_with_bootloader_one(args.bootloader_components, tinfoil):
            bb.warn(
                "On this target the bootloader 1 component and kernel must be "
                "updated together. Adding bootloader 1 component to payload..."
            )
        fname_var_map.update(
            match_files_for_boot_part(deploy_dir_img, tinfoil=tinfoil)
        )

    if not fname_var_map:
        bb.fatal(
            "No update components were found. Have you built them?"
        )

    return fname_var_map


def create_payload(fname_var_map, output_path, tinfoil):
    with tempfile.TemporaryDirectory() as staging_dir:
        staging_dir = pathlib.Path(staging_dir)
        copy_to_staging_dir(fname_var_map, staging_dir, tinfoil=tinfoil)
        create_tar_archive(
            str(output_path), staging_dir, fname_var_map
        )


def main(args):
    """
    Entry point.

    :param args Namespace: argparse Namespace object.
    """
    with bb.tinfoil.Tinfoil() as tinfoil:
        try:
            tinfoil.prepare(config_only=True)
            # Tinfoil throws a SystemExit when it can't find the Layer
            # Directory. This error means the CWD is probably incorrect.
        except SystemExit:
            bb.fatal(
                "Your current working directory must be $TOPDIR, i.e the "
                "build directory, to run this script. If you want to run "
                "this script, or bitbake, from outside the build directory, "
                "you must set $BBPATH to point to the build directory. For "
                "more information see the Yocto mega manual: "
                "https://www.yoctoproject.org/docs/latest/mega-manual/"
                "mega-manual.html#var-BBPATH"
            )

        fname_var_map = get_payload_files_data(args, tinfoil)
        create_payload(fname_var_map, args.tar_output_path, tinfoil)


if __name__ == "__main__":
    sys.exit(main(parse_args()))
