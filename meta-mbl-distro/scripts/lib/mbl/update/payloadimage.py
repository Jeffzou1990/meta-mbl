# Copyright (c) 2019 Arm Limited and Contributors. All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Provides an ABC for creating images for components in an update payload."""

import abc
import logging
import lzma
import shutil
import tarfile

import mbl.util.fileutil as futil


class PayloadImage(abc.ABC):
    """ABC for creating image files for components in an update payload."""

    @abc.abstractmethod
    def stage(self, staging_dir):
        """
        Add the file for this image to a given directory.

        Args:
        * staging_dir Path: The directory in which to add the file for this
          image.

        """
        ...

    @abc.abstractmethod
    def generate_testinfo(self):
        """
        Generate data to be added to a testinfo file for this image.

        The data is a list of test specifications, where each test
        specification has been generated by a function from the testinfo
        module.
        """
        ...

    @property
    @abc.abstractmethod
    def image_type(self):
        """
        Get the "type" of this image.

        I.e. get the name of the swupdate handler used to install the image.
        This should include the format version of the image, e.g. "BOOTv3"
        """
        ...

    @property
    @abc.abstractmethod
    def archived_path(self):
        """
        Get the filename this image should have in the payload archive.

        This must be the name of the file that the stage() method creates.
        """
        ...


def stage_multi_file_component(staging_dir, file_name, archived_file_specs):
    """Create a tar.xz file for a multi-file component in the staging dir."""
    tar_path = staging_dir / file_name
    with tarfile.open(str(tar_path), mode="w:xz") as tar:
        for file_spec in archived_file_specs:
            logging.info(
                'Adding "{}" to "{}" as "{}"'.format(
                    file_spec.path, file_name, file_spec.archived_path
                )
            )
            tar.add(str(file_spec.path), arcname=str(file_spec.archived_path))
    logging.info('Adding "{}" to payload'.format(file_name))


def stage_single_file_with_compression(staging_dir, archived_file_spec):
    """Stage a single file when compression is required."""
    logging.info(
        'Adding "{}" to payload as "{}"'.format(
            archived_file_spec.path, archived_file_spec.archived_path
        )
    )
    out_path = staging_dir / archived_file_spec.archived_path
    with archived_file_spec.path.open("rb") as in_file:
        with lzma.open(str(out_path), "w") as out_file:
            for chunk in futil.read_chunks(in_file):
                out_file.write(chunk)


def stage_single_file(staging_dir, archived_file_spec):
    """Stage a single file when compression is not required."""
    logging.info(
        'Adding "{}" to payload as "{}"'.format(
            archived_file_spec.path, archived_file_spec.archived_path
        )
    )
    try:
        shutil.copy2(
            str(archived_file_spec.path),
            str(staging_dir / archived_file_spec.archived_path),
        )
    except FileNotFoundError:
        bb.fatal(
            'File "{}" was not found. '
            "Have you built the update components?".format(
                str(archived_file_spec)
            )
        )
